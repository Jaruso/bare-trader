"""Rule evaluation engine."""

from dataclasses import dataclass
from decimal import Decimal
from typing import Optional

from trader.api.broker import Broker, OrderSide, OrderType
from trader.rules.models import Rule, RuleAction
from trader.rules.loader import load_rules, mark_triggered
from trader.utils.logging import get_logger
from trader.oms.store import save_order


@dataclass
class Signal:
    """Trading signal generated by rule evaluation."""

    rule: Rule
    current_price: Decimal
    action: RuleAction

    @property
    def side(self) -> OrderSide:
        """Get order side for this signal."""
        return OrderSide.BUY if self.action == RuleAction.BUY else OrderSide.SELL


class RuleEvaluator:
    """Evaluates trading rules against current prices."""

    def __init__(self, broker: Broker) -> None:
        """Initialize evaluator.

        Args:
            broker: Broker instance for price data and order execution.
        """
        self.broker = broker
        self.logger = get_logger("autotrader.rules")

    def evaluate(self, rules: Optional[list[Rule]] = None) -> list[Signal]:
        """Evaluate rules and generate signals.

        Args:
            rules: Rules to evaluate. If None, loads from config.

        Returns:
            List of signals for rules that triggered.
        """
        if rules is None:
            rules = load_rules()

        signals: list[Signal] = []

        for rule in rules:
            if not rule.enabled or rule.triggered:
                continue

            try:
                quote = self.broker.get_quote(rule.symbol)
                # Use midpoint as current price
                current_price = (quote.bid + quote.ask) / 2

                if rule.check(current_price):
                    self.logger.info(
                        f"Rule triggered: {rule.id} | {rule.symbol} @ ${current_price:.2f} "
                        f"(target: ${rule.target_price})"
                    )
                    signals.append(Signal(
                        rule=rule,
                        current_price=current_price,
                        action=rule.action,
                    ))

            except Exception as e:
                self.logger.error(f"Error evaluating rule {rule.id}: {e}")

        return signals

    def execute_signal(self, signal: Signal, dry_run: bool = False) -> Optional[str]:
        """Execute a trading signal.

        Args:
            signal: Signal to execute.
            dry_run: If True, don't actually place order.

        Returns:
            Order ID if executed, None otherwise.
        """
        rule = signal.rule

        self.logger.info(
            f"{'[DRY RUN] ' if dry_run else ''}Executing signal: "
            f"{rule.action.value.upper()} {rule.quantity} {rule.symbol} @ ${signal.current_price:.2f}"
        )

        if dry_run:
            return None

        try:
            order = self.broker.place_order(
                symbol=rule.symbol,
                qty=Decimal(str(rule.quantity)),
                side=signal.side,
                order_type=OrderType.MARKET,
            )

            # Persist order to local OMS store
            try:
                save_order(order)
            except Exception:
                self.logger.exception("Failed to persist order")

            # Mark rule as triggered to prevent re-execution
            mark_triggered(rule.id)

            self.logger.info(
                f"Order placed: {order.id} | {rule.action.value.upper()} {rule.quantity} {rule.symbol} | "
                f"Status: {order.status.value}"
            )

            return order.id

        except Exception as e:
            self.logger.error(f"Error executing signal for rule {rule.id}: {e}")
            return None

    def run_once(self, dry_run: bool = False) -> list[str]:
        """Evaluate all rules and execute signals.

        Args:
            dry_run: If True, don't actually place orders.

        Returns:
            List of order IDs for executed signals.
        """
        signals = self.evaluate()

        if not signals:
            self.logger.debug("No rules triggered")
            return []

        order_ids = []
        for signal in signals:
            order_id = self.execute_signal(signal, dry_run=dry_run)
            if order_id:
                order_ids.append(order_id)

        return order_ids
